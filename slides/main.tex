\documentclass[compress,aspectratio=1610]{beamer}

\usepackage[english]{babel}
\usepackage[english]{isodate}
\isodate
\usepackage{multicol}
\usepackage{csquotes}
\usepackage{soul}

\usetheme{vertex}

\linespread{1.1}

\usepackage{listings}
\lstdefinestyle{cppstyle}{
language=C++,
basicstyle=\scriptsize\ttfamily,
numbers=left,
stringstyle=\ttfamily\color{vertexDarkRed},
commentstyle=\itshape\color{vertexDarkBlue},
captionpos={b},
frame=single
}
\lstset{style=cppstyle}
\lstset{morekeywords={decltype,final}}
\lstset{inputpath=../snippets}
\newcommand{\inputlisting}[1]{\input{../snippets/#1_lst.tex}}

\usepackage{fontspec}
\setmonofont{Hack}

\title{Handedness in C++}
\subtitle{aka Value Categories}
\institute{iCSC 2019}
\author{Nis Meinert}

\begin{document}

\maketitle

\begin{frame}[fragile]{x86-64 Assembly}
    \begin{lstlisting}[language={[x86masm]Assembler}]
instr
instr dest_operand
instr dest_operand, source_operand
instr dest_operand, source_operand, source_operand
    \end{lstlisting}

    \begin{lstlisting}[language={[x86masm]Assembler}]
ret                        ; return
inc rax                    ; increment "rax" by one
mov edx, 1234              ; set "edx" to the value 1234
add rsi, rdi               ; "rsi" += "rdi"
vpaddd ymm1, ymm2, ymm0    ; "ymm1" = "ymm2" + "ymm0"
    \end{lstlisting}
\end{frame}

\begin{frame}{Registers (on Linux)}
    Special purpose:
    \begin{itemize}
        \item return value: \texttt{rax} (64-bit) [\texttt{eax} (32-bit), \texttt{ax} (16-bit), \ldots]
        \item 1st param: \texttt{rdi} (64-bit) [\texttt{edi} (32-bit)]
        \item 2nd param: \texttt{rsi} (64-bit) [\texttt{esi} (32-bit)]
        \item 3rd param: \texttt{rdx} (64-bit) [\texttt{edx} (32-bit)]
        \item \ldots
    \end{itemize}

    Others:
    \begin{itemize}
        \item \texttt{rbx}, \texttt{rcx}, \texttt{rbp}, \texttt{r8-r14}, \texttt{rsp}
        \item \texttt{xmm0-15}
        \item \ldots
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputlisting{snippet1}
        \end{column}
        \begin{column}{.45\textwidth}
            \lstinputlisting[language={[x86masm]Assembler}]{snippet1.asm}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]
    \inputlisting{snippet2}
\end{frame}

\begin{frame}[fragile]{Does this code bother anyone?}
    \inputlisting{snippet3}
\end{frame}

\begin{frame}{Guaranteed Copy Elision}
    \begin{itemize}
        \item It only works because of the \st{guaranteed} accidentally copy elision in GCC (leak in clang)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Q: What is the output of the following program?}
    \inputlisting{snippet4a}
\end{frame}

\begin{frame}[fragile]{A: \texttt{ac}, \texttt{acc}, \texttt{acc}}
    \inputlisting{snippet4a}
\end{frame}

\begin{frame}[fragile]{Q: What is the output of the following program?}
    \inputlisting{snippet4b}
\end{frame}

\begin{frame}[fragile]{A: \texttt{a}, \texttt{a}, \texttt{a}}
    \inputlisting{snippet4b}
\end{frame}

\begin{frame}{Copy Elision}
    \begin{columns}
        \begin{column}{.45\textwidth}
            \inputlisting{snippet4c}
        \end{column}
        \begin{column}{.5\textwidth}
            Mandatory elision of copy/move operations since \texttt{C++17}):
            \begin{itemize}
                \item Return statement: when operand is a \texttt{prvalue} of same class type as return type
                \item Initialization of a variable: when initializer expression is a \texttt{prvalue} of same class type as the variable type
            \end{itemize}
        \end{column}
    \end{columns}
    \ldots even if the copy/move constructor and the destructor have observable side-effects!
    \vspace{.5cm}

    \centering
    \scalebox{1.5}{\textbf{Rule of thumb: avoid naming return values}}
\end{frame}

\end{document}
