\documentclass[compress,aspectratio=1610]{beamer}

\usepackage[english]{babel}
\usepackage[english]{isodate}
\isodate
\usepackage{multicol}
\usepackage{csquotes}
\usepackage{soul}

\usepackage{fancyvrb}

\usetheme{vertex}

%\linespread{1.1}

\usepackage{listings}
\lstdefinestyle{cppstyle}{
language=C++,
basicstyle=\scriptsize\ttfamily,
numbers=left,
stringstyle=\ttfamily\color{vertexDarkRed},
commentstyle=\itshape\color{vertexDarkBlue},
captionpos={b},
frame=single
}
\lstset{style=cppstyle}
\lstset{morekeywords={decltype,final}}
\lstset{inputpath=../snippets}
\newcommand{\inputcpplisting}[1]{\input{../snippets/#1_cpplst.tex}}
\newcommand{\inputasmlisting}[1]{\input{../snippets/#1_asmlst.tex}}

\usepackage{fontspec}
\setmonofont{Hack}

\title{Handedness in C++}
\subtitle{aka Value Categories}
\institute{iCSC 2019}
\author{Nis Meinert}

\begin{document}

\maketitle

\section{Reading Assembly for fun and profit}

\begin{frame}[fragile]{x86-64 Assembly}
    \begin{lstlisting}[language={}]
instr
instr dest_operand
instr dest_operand, source_operand
instr dest_operand, source_operand, source_operand
    \end{lstlisting}

    \begin{lstlisting}[language={}]
ret                        ; return
inc rax                    ; increment "rax" by one
mov edx, 1234              ; set "edx" to the value 1234
add rsi, rdi               ; "rsi" += "rdi"
vpaddd ymm1, ymm2, ymm0    ; "ymm1" = "ymm2" + "ymm0"
    \end{lstlisting}
\end{frame}

\begin{frame}{Registers (on Linux)}
    Special purpose:
    \begin{itemize}
        \item return value: \texttt{rax} (64-bit) [\texttt{eax} (32-bit), \texttt{ax} (16-bit), \ldots]
        \item 1st param: \texttt{rdi} (64-bit) [\texttt{edi} (32-bit)]
        \item 2nd param: \texttt{rsi} (64-bit) [\texttt{esi} (32-bit)]
        \item 3rd param: \texttt{rdx} (64-bit) [\texttt{edx} (32-bit)]
        \item \ldots
    \end{itemize}

    Others:
    \begin{itemize}
        \item \texttt{rbx}, \texttt{rcx}, \texttt{rbp}, \texttt{r8-r14}, \texttt{rsp}
        \item \texttt{xmm0-15}
        \item \ldots
    \end{itemize}
\end{frame}

\begin{frame}[plain]
    \begin{itemize}
        \item EBP and ESP are both just 32-bit general-purpose registers. Although ESP has a special function, which is to act as the stack pointer, and it gets implicitly modified by certain instructions (e.g. push, pop, call). EBP by convention is typically used as a stack frame pointer within functions.
    \end{itemize}
\end{frame}

\begin{frame}[fragile,plain]
    \centering
    \begin{columns}
        \begin{column}{.3\textwidth}
            \begin{lstlisting}[language={}]
leave
            \end{lstlisting}
        \end{column}
        \begin{column}{.2\textwidth}
            \centering
            \scalebox{2.}{$\Leftrightarrow$}
        \end{column}
        \begin{column}{.3\textwidth}
            \begin{lstlisting}[language={}]
mov rsp, rbp
pop rbp
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[plain]
    \begin{itemize}
        \item adjusting \texttt{rsp} in function prologue necessary when function is not a leaf function since callee have to know where to start saving variables on stack. If function is a leaf function, adjusting \texttt{rsp} can be omitted. The offset (\texttt{x} in \texttt{sub rsp, x}) is objective of optimizations such as alignment.
        \item ABI requires that the stack be aligned to 16 bytes when you place the call. Alternatively speaking, that it be off 16 bytes alignment as you get called (as CALL pushes 8 bytes).
        \item \texttt{CALL} inserts 8 bytes in the stack, the return address
        \item \texttt{RET} pops it and transfers control there
        \item \texttt{CALL} = \texttt{PUSH} <address of next instruction; JMP <target>
        \item Clang's choice is probably instruction size: \texttt{PUSH RAX} and \texttt{POP RCX} are each 1 byte; the GCC's \texttt{ADD} are 4 bytes.
        \item the \texttt{MOVDQA} and \texttt{MOVAPS} instructions require 16-byte alignment.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{lea dest, src}}
    \begin{columns}
        \begin{column}{.5\textwidth}
            \begin{itemize}
                \item \underline{l}oad \underline{e}ffective \underline{a}ddress
                \item puts memory address from \texttt{src} into the destination \texttt{dest}
                \item Example: \texttt{lea eax, [ebx+8]}
                \begin{itemize}
                    \item put \texttt{[ebx+8]} into \texttt{EAX}
                    \item value of \texttt{EAX} after instruction: \texttt{0x00403A48}
                \end{itemize}
                \item \ldots whereas: \texttt{mov eax, [ebx+8]}
                \begin{itemize}
                    \item value of \texttt{EAX} after instruction: \texttt{0x0012C140}
                \end{itemize}
            \end{itemize}
        \end{column}
        \begin{column}{.5\textwidth}
            \begin{Verbatim}
           ┌──────────────────┐
           │ Registers        │
           ├──────────────────┤
           │ EAX = 0x00000000 │ 
           │ EBX = 0x00403A40 │ 
           └──────────────────┘
           ┌────────────┐
           │ Memory     │
           ├────────────┤
0x00403A40 │ 0x7C81776F │ 
0x00403A44 │ 0x7C911000 │ 
0x00403A48 │ 0x0012C140 │ 
0x00403A4C │ 0x7FFDB000 │ 
           └────────────┘
            \end{Verbatim}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Reading Assembly for Fun and Profit}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet5a}
            
            \only<2>{%
            \inputasmlisting{snippet5b}}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet5a}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Reading Assembly for Fun and Profit}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet6a}

            \only<2>{%
            \inputasmlisting{snippet6b}}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet6a}
        \end{column}
    \end{columns}

\end{frame}

\section{Implicit Costs of \texttt{const \&}}

\begin{frame}[fragile]{Implicit Costs of using \texttt{const \&}}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet1a}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet1a}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Implicit Costs of using \texttt{const \&}}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet2a}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet2b}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Implicit Costs of using \texttt{const \&}}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet1a}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet2a}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Implicit Costs of using \texttt{const \&}}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet1b}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet2b}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]
    \inputcpplisting{snippet8}
\end{frame}

\begin{frame}[fragile]{Does this code bother anyone?}
    \inputcpplisting{snippet3}
\end{frame}

\begin{frame}{Guaranteed Copy Elision}
    \begin{itemize}
        \item It only works because of the \st{guaranteed} accidentally copy elision in GCC (leak in clang) TODO: named RVO (NRVO) is not guaranteed
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Q: What is the output of the following program?}
    \inputcpplisting{snippet4a}
\end{frame}

\begin{frame}[fragile]{A: \texttt{ac}, \texttt{acc}, \texttt{acc}}
    \inputcpplisting{snippet4a}
\end{frame}

\begin{frame}[fragile]{Q: What is the output of the following program?}
    \inputcpplisting{snippet4b}
\end{frame}

\begin{frame}[fragile]{A: \texttt{a}, \texttt{a}, \texttt{a}}
    \inputcpplisting{snippet4b}
\end{frame}

\begin{frame}{Copy Elision}
    \begin{columns}
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet10}
        \end{column}
        \begin{column}{.5\textwidth}
            Mandatory elision of copy/move operations since \texttt{C++17}):
            \begin{itemize}
                \item Return statement: when operand is a \texttt{prvalue} of same class type as return type
                \item Initialization of a variable: when initializer expression is a \texttt{prvalue} of same class type as the variable type
            \end{itemize}
        \end{column}
    \end{columns}
    \ldots even if the copy/move constructor and the destructor have observable side-effects!
    \vspace{.5cm}

    \centering
    \scalebox{1.5}{\textbf{Rule of thumb: avoid naming return values}}
\end{frame}

\begin{frame}{Implicit \texttt{move} on Return}
    \begin{itemize}
        \item Q: What happens on \texttt{return expression}?
        \item A: The \texttt{expression} gets evaluated, the current function is terminated and the result of the \texttt{expression} is returned to the caller, \textbf{after implicit conversion} to the function return type.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Q: Why can't we use perfect forwarding here?}
    \inputcpplisting{snippet9}

    \only<2>{\textbf{A:} The first call in the loop might \textit{steal} the values, leading to unexpected behavior calling \texttt{op} in subsequent iterations.}
\end{frame}

\begin{frame}[fragile]{\texttt{decltype(auto)} or \texttt{auto \&\&}}
    \texttt{auto} behaves much like a \texttt{T} in a function template:
    \begin{lstlisting}
template <typename T>
void f(T && x) { ... };
    \end{lstlisting}
    \ldots \texttt{x} will \textbf{always} be a reference of some kind
    \begin{lstlisting}
// if `y` is lvalue, `x` is lvalue reference
// if `y` is rvalue, `x` is rvalue reference
f(y); // auto &&x = y;
f<decltype(y)>(y); // decltype(auto) x = y;
    \end{lstlisting}
    whereas \texttt{decltype(auto)} is like explicitly specifying the type via \texttt{decltype(y)}:
    \begin{lstlisting}
decltype(auto) a = g();
decltype(g()) b = g(); // equivalent
    \end{lstlisting}

    $\Rightarrow$ \texttt{auto \&\&} is always be a reference, \texttt{decltype(auto)} is not. \texttt{auto \&\&}'s lifetime extension for rvalues only works with local variables: binding a temporary return value to an \texttt{auto \&\&} creates a reference to a temporary which will dangle when the return values is destructed. 
\end{frame}

\begin{frame}[fragile]
    \begin{columns}
        \begin{column}{.5\textwidth}
            \inputcpplisting{snippet7}
        \end{column}
        \begin{column}{.4\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi}]
S::S(int):
  push rbp
  mov rbp, rsp
  mov QWORD PTR [rbp-8], rdi
  mov DWORD PTR [rbp-12], esi
  mov rax, QWORD PTR [rbp-8]
  mov edx, DWORD PTR [rbp-12]
  mov DWORD PTR [rax], edx
  nop
  pop rbp
  ret
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]
    \begin{columns}
        \begin{column}{.5\textwidth}
            \inputcpplisting{snippet7}
        \end{column}
        \begin{column}{.4\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi}]
S::~S() [base object destructor]:
  push rbp
  mov rbp, rsp
  mov QWORD PTR [rbp-8], rdi
  nop
  pop rbp
  ret
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]
    \begin{columns}
        \begin{column}{.5\textwidth}
            \inputcpplisting{snippet7}
        \end{column}
        \begin{column}{.4\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi}]
f():
  [...]
  mov QWORD PTR [rbp-24], rdi
  lea rax, [rbp-4]
  mov esi, 42
  mov rdi, rax
  call S::S(int)
  lea rdx, [rbp-4]
  mov rax, QWORD PTR [rbp-24]
  mov rsi, rdx
  mov rdi, rax
  call S::S(S const&)
  lea rax, [rbp-4]
  mov rdi, rax
  call S::~S()
  nop
  mov rax, QWORD PTR [rbp-24]
  [...]
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]
    \begin{columns}
        \begin{column}{.5\textwidth}
            \inputcpplisting{snippet7}
        \end{column}
        \begin{column}{.4\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi}]
g():
  [...]
  sub rsp, 24
  lea rax, [rbp-20]
  mov rdi, rax
  call f()
  lea rdx, [rbp-20]
  lea rax, [rbp-24]
  mov rsi, rdx
  mov rdi, rax
  call S::S(S const&)
  lea rax, [rbp-20]
  mov rdi, rax
  call S::~S()
  mov ebx, DWORD PTR [rbp-24]
  lea rax, [rbp-24]
  mov rdi, rax
  call S::~S()
  mov eax, ebx
  [...]
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Forwarding Values and Preserving Value Category}
    \centering

    \scalebox{.7}{(derived from \href{https://youtu.be/hwT8K3-NH1w}{CppCon 2018: \textit{Hayun Ezra Chung} \enquote{Forwarding Values... and Backwarding Them Too?})}}

    \only<1>{\inputcpplisting{snippet11a}}%
    \only<2>{\inputcpplisting{snippet11b}}%
    \only<3>{\inputcpplisting{snippet11c}}%
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \only<1>{\inputcpplisting{snippet18a}}%
    \only<2>{\inputcpplisting{snippet18b}}%
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \textbf{Q:} Why is this a bad idea?
    \begin{lstlisting}
auto&& visit(auto visitor) {
    auto&& result = visitor(resource);
    return result;
}
    \end{lstlisting}
    
    \only<2>{%
    \textbf{A:} Dangling reference for

    \centering
    \texttt{visit([](Resource \&r) -> Resource \{ return r; \}));}

    \vspace{.5cm}

    \begin{center}
        \scalebox{1.5}{\texttt{auto\&\&} is always a reference!}
    \end{center}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \only<1>{\inputcpplisting{snippet12a}}%
    \only<2>{\inputcpplisting{snippet12b}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \only<1>{\inputcpplisting{snippet12a}}%
    \only<2>{\inputcpplisting{snippet12b}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \only<1>{\inputcpplisting{snippet13a}}%
    \only<2>{\inputcpplisting{snippet13b}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \centering
    \only<1>{\inputcpplisting{snippet14a}}%
    \only<2,3>{%
        \only<3>{\textbf{\textcolor{vertexDarkRed}{error:}} cannot bind rvalue reference of type \enquote{Resource\&\&} to lvalue of type \enquote{Resource}}%
        \inputcpplisting{snippet14b}%
    }%
    \only<4>{\inputcpplisting{snippet14c}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Categroy}
    \centering
    \scalebox{1.5}{How do we fuse these implementations?}

    \begin{lstlisting}
Resource visit(auto visitor) {
    Resource result = visitor(resource);
    return result;
}

Resource& visit(auto visitor) {
    Resource& result = visitor(resource);
    return result;
}

Resource&& visit(auto visitor) {
    Resource&& result = visitor(resource);
    return static_cast<Resource&&>(result);
}
    \end{lstlisting}

    \begin{lstlisting}
Target(rm.visit([](Resource &r) -> Resource { return r; }));
Target(rm.visit([](Resource &r) -> Resource& { return r; }));
Target(rm.visit([](Resource &r) -> Resource&& { return std::move(r); }));
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Categroy}
    \centering
    \scalebox{1.5}{How do we fuse these implementations?}

    \begin{lstlisting}
Resource visit(auto visitor) {
    Resource result = visitor(resource);
    return result;
}

Resource& visit(auto visitor) {
    Resource& result = visitor(resource);
    return result;
}

Resource&& visit(auto visitor) {
    Resource&& result = visitor(resource);
    return static_cast<Resource&&>(result);
}
    \end{lstlisting}

    \begin{lstlisting}
decltype(auto) visit(auto visitor) {
    decltype(auto) result = visitor(resource);
    return static_cast<decltype(result)>(result);
}
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile,plain,noframenumbering]
    \centering
    \scalebox{.7}{(derived from \href{https://youtu.be/hwT8K3-NH1w}{CppCon 2018: \textit{Hayun Ezra Chung} \enquote{Forwarding Values... and Backwarding Them Too?})}}

    \inputcpplisting{snippet15}
\end{frame}

\begin{frame}[plain,noframenumbering]
    \centering
    \scalebox{5.}{\color{vertexDarkRed}$*$}
\end{frame}

\begin{frame}[fragile]{Q: What is the Output of the Program?}
    \inputcpplisting{snippet16a}
\end{frame}

\begin{frame}[fragile]{A: \texttt{a}}
    \inputcpplisting{snippet16a}
\end{frame}

\begin{frame}[fragile]{Q: What is the Output of the Program?}
    \inputcpplisting{snippet16b}
\end{frame}

\begin{frame}[fragile]{A: \texttt{aa}}
    \inputcpplisting{snippet16b}
\end{frame}

\begin{frame}[fragile]{Missing (N)RVO}
    \begin{lstlisting}
struct Resource {
    ...
    Resource(const Resource&) { std::cout << 'a'; }
};

Resource visit(auto visitor) {
    Resource result = visitor(resource);
    return static_cast<Resource>(result);
}
    \end{lstlisting}

    \textbf{Neither RVO nor NRVO!}
    \begin{itemize}
        \item \texttt{static\_cast} is not the name of a variable
        \item compiler cannot elide observable side effects of copy construction
        \item \enquote{Solution}
        \begin{itemize}
            \item remove explicit cast, or
            \item remove side effect (\texttt{std::cout})
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Missing (N)RVO}
    \begin{lstlisting}
template <typename T>
decltype(auto) visit(T visitor) {
    decltype(auto) result = visitor(resource);
    if constexpr (std::is_same_v<decltype(result), Resource&&>) {
        return std::move(result);
    } else {
        return result;
    }
}
    \end{lstlisting}

    \hfill \ldots works for GCC (without \texttt{auto} concept), not for clang though
\end{frame}

\begin{frame}[fragile,plain,noframenumbering]
    \inputcpplisting{snippet17}
\end{frame}

\begin{frame}{Conclusion}
    \begin{center}
        \scalebox{.7}{(shamelessly copied from \href{https://youtu.be/hwT8K3-NH1w}{CppCon 2018: \textit{Hayun Ezra Chung} \enquote{Forwarding Values... and Backwarding Them Too?})}}
    \end{center}
    
    \textbf{Forwarding}
    \begin{itemize}
        \item Parameter Type: \texttt{T\&\&}
        \item Function Argument: \texttt{std::forward<E>(e)}
        \item Alternatively: \texttt{static\_cast<decltype(e)\&\&>(e)}
    \end{itemize}

    \textbf{Backwarding}
    \begin{itemize}
        \item Parameter Type: \texttt{decltype(auto)}
        \item Function Argument: \texttt{decltype(e)(e)}
        \item Alternatively: \texttt{static\_cast<decltype(e)>(e)}$^*$
    \end{itemize}
\end{frame}

\end{document}
