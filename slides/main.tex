\documentclass[compress,aspectratio=1610]{beamer}

\usepackage[english]{babel}
\usepackage[english]{isodate}
\isodate
\usepackage{multicol}
\usepackage{csquotes}
\usepackage{soul}

\usepackage{fancyvrb}

\usetheme{vertex}

%\linespread{1.1}

\usepackage{graphicx}
\graphicspath{{../img/}}

\usepackage{listings}
\lstdefinestyle{cppstyle}{
language=C++,
basicstyle=\scriptsize\ttfamily,
numbers=left,
stringstyle=\ttfamily\color{vertexDarkRed},
commentstyle=\itshape\color{vertexDarkBlue},
captionpos={b},
frame=single,
morekeywords={constexpr,noexcept},
breaklines=true,
postbreak=\mbox{$\hookrightarrow$\space},
showstringspaces=false
}
\lstset{style=cppstyle}
\lstset{morekeywords={decltype,final}}
\lstset{inputpath=../snippets}
\newcommand{\inputcpplisting}[1]{\input{../snippets/#1_cpplst.tex}}
\newcommand{\inputasmlisting}[1]{\input{../snippets/#1_asmlst.tex}}

\usepackage{fontspec}
\setmonofont{Hack}

\title{Demystifying Value Categories in C++}
\subtitle{iCSC 2020}
\institute{Rostock University}
\author{Nis Meinert}
\date{}

\begin{document}

\maketitle

\section{Reading Assembly for fun and profit}

\begin{frame}[fragile]{Moving \texttt{std::string}}
    \centering
    \scalebox{.7}{(derived from \href{https://youtu.be/oTMSgI1XjF8}{CppCon 2019: \textit{Ben Deane} \enquote{Everyday Efficiency: In-Place Construction (Back to Basics?)})}}

    \begin{lstlisting}
static void cp_small_str(benchmark::State& state) {
    for (auto _ : state) {
        std::string original("small");
        benchmark::DoNotOptimize(original);
        std::string copied = original;
        benchmark::DoNotOptimize(copied);
    }
}
BENCHMARK(cp_small_str);
    \end{lstlisting}

    \begin{lstlisting}
static void mv_small_str(benchmark::State& state) {
    for (auto _ : state) {
        std::string original("small");
        benchmark::DoNotOptimize(original);
        std::string moved = std::move(original);
        benchmark::DoNotOptimize(moved);
    }
}
BENCHMARK(mv_small_str);
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Moving \texttt{std::string}}
    \centering
    \scalebox{.7}{(derived from \href{https://youtu.be/oTMSgI1XjF8}{CppCon 2019: \textit{Ben Deane} \enquote{Everyday Efficiency: In-Place Construction (Back to Basics?)})}}

    \begin{lstlisting}
static void cp_long_str(benchmark::State& state) {
    for (auto _ : state) {
        std::string original("this is too long for short string optimization");
        benchmark::DoNotOptimize(original);
        std::string copied = original;
        benchmark::DoNotOptimize(copied);
    }
}
BENCHMARK(cp_long_str);
    \end{lstlisting}

    \begin{lstlisting}
static void mv_long_str(benchmark::State& state) {
    for (auto _ : state) {
        std::string original("this is too long for short string optimization");
        benchmark::DoNotOptimize(original);
        std::string moved = std::move(original);
        benchmark::DoNotOptimize(moved);
    }
}
BENCHMARK(mv_long_str);
    \end{lstlisting}
\end{frame}

\begin{frame}{Moving \texttt{std::string}}
    \centering
    \scalebox{1.5}{Quick Bench result}

    \includegraphics[width=.9\textwidth]{benchmark_str_cp_mv.png}

    Quick Bench: \href{http://quick-bench.com/l_4Ith4ZvZbSE0UIfIQXVpkg84A}{\texttt{tinyurl.com/yybmdngv}}
\end{frame}

\begin{frame}[fragile]{Moving \texttt{std::string}}
    \centering

    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \begin{block}{Copy small \texttt{std::string}}
                \begin{enumerate}
                    \item copy stack allocated data
                \end{enumerate}
            \end{block}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{block}{Move small \texttt{std::string}}
                \begin{enumerate}
                    \item copy stack allocated data
                    \item set string length of moved string to zero
                \end{enumerate}
            \end{block}
        \end{column}
    \end{columns}

    \vspace{5mm}

    \begin{center}
        \scalebox{1.5}{$\hookrightarrow$ moving is not necessarily better than copying!}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Moving \texttt{std::map}}
    \textbf{Did they forget to mark the move ctor \texttt{noexcept}?} \only<2>{\textcolor{vertexDarkRed}{No!}}

    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[numbers=none]
// since C++11
std:map(const std:map&&)

// until C++17
std:map& operator(std:map&&)

// since C++17
std:map& operator(std:map&&) noexcept
            \end{lstlisting}
        \end{column}
        \begin{column}{.5\textwidth}
            \begin{itemize}
                \item<2> Move ctor needs to allocate new sentinel node, because moved from container must still be a valid container (albeit in an unspecified state)
                \item<2> Move assignment can swap, thus no need to allocate
            \end{itemize}
        \end{column}
    \end{columns}

    \only<2>{%
    \begin{center}
        \scalebox{1.5}{$\hookrightarrow$ move ctor of \texttt{std::map} allocates heap space!}

        \scalebox{.8}{(Billy O'Neal: \href{https://twitter.com/MalwareMinigun/status/1165310509022736384}{\texttt{twitter.com/MalwareMinigun/status/1165310509022736384})}}
    \end{center}}
\end{frame}

\begin{frame}[fragile]{Moving \texttt{std::map}}
    \begin{lstlisting}
static void rvo(benchmark::State& state) {
    for (auto _ : state) {
        auto m = []() -> std::map<int, int> {
            std::map<int, int> m{{0, 42}};
            return m;
        }();
        benchmark::DoNotOptimize(m);
    }
}
BENCHMARK(rvo);
    \end{lstlisting}

    \begin{lstlisting}
static void fmove(benchmark::State& state) {
    for (auto _ : state) {
        auto m = []() -> std::map<int, int> {
            std::map<int, int> m{{0, 42}};
            return std::move(m);
        }();
        benchmark::DoNotOptimize(m);
    }
}
BENCHMARK(fmove);
    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Moving \texttt{std::map}}
    \begin{lstlisting}
static void copy(benchmark::State& state) {
    for (auto _ : state) {
        std::map<int, int> m{{0, 42}};
        benchmark::DoNotOptimize(m);
        auto m2 = m;
        benchmark::DoNotOptimize(m2);
    }
}
BENCHMARK(copy);
    \end{lstlisting}
\end{frame}

\begin{frame}{Moving \texttt{std::map}}
    \centering
    \scalebox{1.5}{Quick Bench result}

    \includegraphics[width=.9\textwidth]{benchmark_map_mv.png}

    Quick Bench: \href{http://quick-bench.com/7L-__vxvraDDacztJoalrjBrMUA}{\texttt{tinyurl.com/y57egvjp}}
\end{frame}

\begin{frame}[plain,noframenumbering]
    \centering
    \scalebox{5}{\only<1>{Why?}\only<2>{RVO!}}

    \only<2>{Ben Deane: \enquote{Perhaps the most important optimization the compiler does}}
\end{frame}

\begin{frame}[fragile]{x86-64 Assembly}
    \begin{lstlisting}[language={}]
instr
instr dest_operand
instr dest_operand, source_operand
instr dest_operand, source_operand, source_operand
    \end{lstlisting}

    \begin{lstlisting}[language={}]
ret                        ; return
inc rax                    ; increment "rax" by one
mov edx, 1234              ; set "edx" to the value 1234
add rsi, rdi               ; "rsi" += "rdi"
vpaddd ymm1, ymm2, ymm0    ; "ymm1" = "ymm2" + "ymm0"
    \end{lstlisting}
\end{frame}

\begin{frame}{Registers (on Linux)}
    Special purpose:
    \begin{itemize}
        \item return value: \texttt{rax} (64-bit) [\texttt{eax} (32-bit), \texttt{ax} (16-bit), \ldots]
        \item 1st param: \texttt{rdi} (64-bit) [\texttt{edi} (32-bit)]
        \item 2nd param: \texttt{rsi} (64-bit) [\texttt{esi} (32-bit)]
        \item 3rd param: \texttt{rdx} (64-bit) [\texttt{edx} (32-bit)]
        \item \ldots
    \end{itemize}

    Others:
    \begin{itemize}
        \item \texttt{rbx}, \texttt{rcx}, \texttt{rbp}, \texttt{r8-r14}, \texttt{rsp}
        \item \texttt{xmm0-15}
        \item \ldots
    \end{itemize}
\end{frame}

\begin{frame}[plain]
    \begin{itemize}
        \item EBP and ESP are both just 32-bit general-purpose registers. Although ESP has a special function, which is to act as the stack pointer, and it gets implicitly modified by certain instructions (e.g. push, pop, call). EBP by convention is typically used as a stack frame pointer within functions.
    \end{itemize}
\end{frame}

\begin{frame}[fragile,plain]
    \centering
    \begin{columns}
        \begin{column}{.3\textwidth}
            \begin{lstlisting}[language={}]
leave
            \end{lstlisting}
        \end{column}
        \begin{column}{.2\textwidth}
            \centering
            \scalebox{2.}{$\Leftrightarrow$}
        \end{column}
        \begin{column}{.3\textwidth}
            \begin{lstlisting}[language={}]
mov rsp, rbp
pop rbp
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[plain]
    \begin{itemize}
        \item adjusting \texttt{rsp} in function prologue necessary when function is not a leaf function since callee have to know where to start saving variables on stack. If function is a leaf function, adjusting \texttt{rsp} can be omitted. The offset (\texttt{x} in \texttt{sub rsp, x}) is objective of optimizations such as alignment.
        \item ABI requires that the stack be aligned to 16 bytes when you place the call. Alternatively speaking, that it be off 16 bytes alignment as you get called (as CALL pushes 8 bytes).
        \item \texttt{CALL} inserts 8 bytes in the stack, the return address
        \item \texttt{RET} pops it and transfers control there
        \item \texttt{CALL} = \texttt{PUSH} <address of next instruction; JMP <target>
        \item Clang's choice is probably instruction size: \texttt{PUSH RAX} and \texttt{POP RCX} are each 1 byte; the GCC's \texttt{ADD} are 4 bytes.
        \item the \texttt{MOVDQA} and \texttt{MOVAPS} instructions require 16-byte alignment.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{lea dest, src}}
    \begin{columns}
        \begin{column}{.5\textwidth}
            \begin{itemize}
                \item \underline{l}oad \underline{e}ffective \underline{a}ddress
                \item puts memory address from \texttt{src} into the destination \texttt{dest}
                \item Example: \texttt{lea eax, [ebx+8]}
                \begin{itemize}
                    \item put \texttt{[ebx+8]} into \texttt{EAX}
                    \item value of \texttt{EAX} after instruction: \texttt{0x00403A48}
                \end{itemize}
                \item \ldots whereas: \texttt{mov eax, [ebx+8]}
                \begin{itemize}
                    \item value of \texttt{EAX} after instruction: \texttt{0x0012C140}
                \end{itemize}
            \end{itemize}
        \end{column}
        \begin{column}{.5\textwidth}
            \begin{Verbatim}
           ┌──────────────────┐
           │ Registers        │
           ├──────────────────┤
           │ EAX = 0x00000000 │ 
           │ EBX = 0x00403A40 │ 
           └──────────────────┘
           ┌────────────┐
           │ Memory     │
           ├────────────┤
0x00403A40 │ 0x7C81776F │ 
0x00403A44 │ 0x7C911000 │ 
0x00403A48 │ 0x0012C140 │ 
0x00403A4C │ 0x7FFDB000 │ 
           └────────────┘
            \end{Verbatim}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Reading Assembly for Fun and Profit}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet5a}
            
            \only<2>{%
            \inputasmlisting{snippet5b}}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet5a}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Reading Assembly for Fun and Profit}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet6a}

            \only<2>{%
            \inputasmlisting{snippet6b}}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet6a}
        \end{column}
    \end{columns}

\end{frame}

\section{Implicit Costs of \texttt{const \&}}

\begin{frame}[fragile]{Implicit Costs of using \texttt{const \&}}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet1a}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet1a}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Implicit Costs of using \texttt{const \&}}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet2a}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet2b}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Implicit Costs of using \texttt{const \&}}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet1a}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet2a}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Implicit Costs of using \texttt{const \&}}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet1b}
        \end{column}
        \begin{column}{.45\textwidth}
            \inputasmlisting{snippet2b}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]
    \inputcpplisting{snippet8}
\end{frame}

\begin{frame}[fragile]{Does this code bother anyone?}
    \inputcpplisting{snippet3}
\end{frame}

\begin{frame}[fragile]{Q: What is the output of the program?}
    \begin{center}
        Compiler flags: \texttt{-std=c++14 -fno-elide-constructors}
    \end{center}

    \inputcpplisting{snippet4a}
\end{frame}

\begin{frame}[fragile]{A: \texttt{ac}, \texttt{acc}, \texttt{acc}}
    \begin{center}
        Compiler flags: \texttt{-std=c++14 -fno-elide-constructors}
    \end{center}

    \inputcpplisting{snippet4a}
\end{frame}

\begin{frame}[fragile]{Q: What is the output of the program?}
    \begin{center}
        Compiler flags: \texttt{-std=c++17}
    \end{center}

    \inputcpplisting{snippet4b}
\end{frame}

\begin{frame}[fragile]{A: \texttt{a}, \texttt{a}, \texttt{a}}
    \begin{center}
        Compiler flags: \texttt{-std=c++17}
    \end{center}

    \inputcpplisting{snippet4b}
\end{frame}

\begin{frame}{Copy Elision}
    \begin{columns}
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet10}
        \end{column}
        \begin{column}{.5\textwidth}
            Mandatory elision of copy/move operations since \texttt{C++17}):
            \begin{itemize}
                \item Return statement: when operand is a \texttt{prvalue} of same class type as return type
                \item Initialization of a variable: when initializer expression is a \texttt{prvalue} of same class type as the variable type
            \end{itemize}
        \end{column}
    \end{columns}
    \ldots even if the copy/move constructor and the destructor have observable side-effects!
    \vspace{.5cm}

    \centering
    \scalebox{1.5}{\textbf{Rule of thumb: avoid naming return values}}
\end{frame}

\begin{frame}{Implicit \texttt{move} on Return}
    \begin{itemize}
        \item Q: What happens on \texttt{return expression}?
        \item A: The \texttt{expression} gets evaluated, the current function is terminated and the result of the \texttt{expression} is returned to the caller, \textbf{after implicit conversion} to the function return type.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Q: Why can't we use perfect forwarding here?}
    \inputcpplisting{snippet9}

    \only<2>{\textbf{A:} The first call in the loop might \textit{steal} the values, leading to unexpected behavior calling \texttt{op} in subsequent iterations.}
\end{frame}

\begin{frame}[fragile]{Temporary object lifetime (extension)}
    \inputcpplisting{snippet22}

    \href{https://en.cppreference.com/w/cpp/language/lifetime}{\texttt{cppreference.com}}: \enquote{The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference (since C++11).}
\end{frame}

\begin{frame}[fragile]{\texttt{decltype(auto)} or \texttt{auto \&\&}}
    \texttt{auto} behaves much like a \texttt{T} in a function template:
    \begin{lstlisting}
template <typename T>
void f(T && x) { ... };
    \end{lstlisting}
    \ldots \texttt{x} will \textbf{always} be a reference of some kind
    \begin{lstlisting}
// if `y` is lvalue, `x` is lvalue reference
// if `y` is rvalue, `x` is rvalue reference
f(y); // auto &&x = y;
f<decltype(y)>(y); // decltype(auto) x = y;
    \end{lstlisting}
    whereas \texttt{decltype(auto)} is like explicitly specifying the type via \texttt{decltype(y)}:
    \begin{lstlisting}
decltype(auto) a = g();
decltype(g()) b = g(); // equivalent
    \end{lstlisting}

    $\Rightarrow$ \texttt{auto\&\&} is always be a reference, \texttt{decltype(auto)} is not. \texttt{auto\&\&}'s lifetime extension for rvalues only works with local variables: binding a temporary return value to an \texttt{auto\&\&} creates a reference to a temporary which will dangle when the return values is destructed. 
\end{frame}

\begin{frame}[fragile]{\texttt{C++} Objects in Assembly}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet20}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi},numbers=none]
  | main:
14|   push rbp
14|   mov rbp, rsp
14|   sub rsp, 16
14|   mov dword ptr [rbp - 4], 0
15|   lea rdi, [rbp - 16]
15|   mov esi, 1
15|   mov edx, 2
15|   mov ecx, 3
15|   call S::S(int, int, int)
16|   lea rdi, [rbp - 16]
16|   call S::sum()
16|   mov dword ptr [rbp - 4], eax
17|   lea rdi, [rbp - 16]
17|   call S::~S()
17|   mov eax, dword ptr [rbp - 4]
17|   add rsp, 16
17|   pop rbp
17|   ret
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{\texttt{C++} Objects in Assembly}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet20}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi},numbers=none]
  | S::S(int, int, int):
 5|   push rbp
 5|   mov rbp, rsp
 5|   mov qword ptr [rbp - 8], rdi
 5|   mov dword ptr [rbp - 12], esi
 5|   mov dword ptr [rbp - 16], edx
 5|   mov dword ptr [rbp - 20], ecx
 5|   mov rax, qword ptr [rbp - 8]
 5|   mov ecx, dword ptr [rbp - 12]
 5|   mov dword ptr [rax], ecx
 5|   mov ecx, dword ptr [rbp - 16]
 5|   mov dword ptr [rax + 4], ecx
 5|   mov ecx, dword ptr [rbp - 20]
 5|   mov dword ptr [rax + 8], ecx
 5|   pop rbp
 5|   ret
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{\texttt{C++} Objects in Assembly}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet20}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi},numbers=none]
  | S::sum():
 9|   push rbp
 9|   mov rbp, rsp
 9|   mov qword ptr [rbp - 8], rdi
 9|   mov rax, qword ptr [rbp - 8]
10|   mov ecx, dword ptr [rax]
10|   add ecx, dword ptr [rax + 4]
10|   add ecx, dword ptr [rax + 8]
10|   mov eax, ecx
10|   pop rbp
10|   ret
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{RVO in Assembly}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet7}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi},numbers=none]
# g92 -fno-elide-constructors
  | g():
  |   [...]
14|   lea rax, [rbp-20]
14|   mov rdi, rax
14|   call f()
14|   lea rdx, [rbp-20]
14|   lea rax, [rbp-24]
14|   mov rsi, rdx
14|   mov rdi, rax
14|   call S::S(S&&)
14|   lea rax, [rbp-20]
14|   mov rdi, rax
14|   call S::~S()
15|   mov ebx, DWORD PTR [rbp-24]
14|   lea rax, [rbp-24]
14|   mov rdi, rax
14|   call S::~S()
15|   mov eax, ebx
  |   [...]      
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{RVO in Assembly}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \inputcpplisting{snippet7}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi},numbers=none]
# g92 -fno-elide-constructors
  | f():
  |   [...]
 9|   mov QWORD PTR [rbp-24], rdi
10|   lea rax, [rbp-4]
10|   mov esi, 42
10|   mov rdi, rax
10|   call S::S(int)
10|   lea rdx, [rbp-4]
10|   mov rax, QWORD PTR [rbp-24]
10|   mov rsi, rdx
10|   mov rdi, rax
10|   call S::S(S&&)
10|   lea rax, [rbp-4]
10|   mov rdi, rax
10|   call S::~S()
  |   [...]      
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{RVO in Assembly}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi}]
# g92 -fno-elide-constructors
f():
  [...]
  mov QWORD PTR [rbp-24], rdi
  lea rax, [rbp-4]
  mov esi, 42
  mov rdi, rax
  call S::S(int)
  lea rdx, [rbp-4]
  mov rax, QWORD PTR [rbp-24]
  mov rsi, rdx
  mov rdi, rax
  call S::S(S&&)
  lea rax, [rbp-4]
  mov rdi, rax
  call S::~S()
  nop
  mov rax, QWORD PTR [rbp-24]
  leave
  ret
            \end{lstlisting}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi}]
# g92
f():
  [...]
  mov QWORD PTR [rbp-8], rdi
  mov rax, QWORD PTR [rbp-8]
  mov esi, 42
  mov rdi, rax
  call S::S(int)
  mov rax, QWORD PTR [rbp-8]
  leave
  ret
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{RVO in Assembly}
    \begin{columns}[t]
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi}]
# g92 -fno-elide-constructors
g():
  [...]
  lea rax, [rbp-20]
  mov rdi, rax
  call f()
  lea rdx, [rbp-20]
  lea rax, [rbp-24]
  mov rsi, rdx
  mov rdi, rax
  call S::S(S&&)
  lea rax, [rbp-20]
  mov rdi, rax
  call S::~S()
  mov ebx, DWORD PTR [rbp-24]
  lea rax, [rbp-24]
  mov rdi, rax
  call S::~S()
  mov eax, ebx
  [...]      
            \end{lstlisting}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{lstlisting}[language={},morekeywords={rdi}]
# g92
g():
  [...]
  lea rax, [rbp-20]
  mov rdi, rax
  call f()
  mov ebx, DWORD PTR [rbp-20]
  lea rax, [rbp-20]
  mov rdi, rax
  call S::~S()
  mov eax, ebx
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{(N)RVO or no (N)RVO?}
    \inputcpplisting{snippet21}
    \begin{itemize}
        \item \texttt{f1}: \only<1>{???}\only<2>{RVO}
        \item \texttt{f2}: \only<1>{???}\only<2>{\texttt{call S::S(S\&\&)}}
        \item \texttt{f3}: \only<1>{???}\only<2>{RVO}
        \item \texttt{f4}: \only<1>{???}\only<2>{\texttt{call S::S(const S\&)} (silently revert to a copy!)}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{(N)RVO or no (N)RVO?}
    \inputcpplisting{snippet25}
    \begin{itemize}
        \item \texttt{f1}: \only<1>{???}\only<2>{No RVO: the object has to be constructed inside the function}
        \item \texttt{f2}: \only<1>{???}\only<2>{same as \texttt{f1}}
        \item \texttt{f3}: \only<1>{???}\only<2>{same as \texttt{f1}}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{(N)RVO or no (N)RVO?}
    \inputcpplisting{snippet23}

    \only<2>{No RVO: \texttt{call S::S(S const\&)}}
\end{frame}

\begin{frame}[fragile]{(N)RVO or no (N)RVO?}
    \inputcpplisting{snippet26}
    \begin{itemize}
        \item \texttt{f1}: \only<1>{???}\only<2>{RVO: type of ternary is prvalue}
        \item \texttt{f2}: \only<1>{???}\only<2>{No RVO: type of ternary is lvalue reference}
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{(N)RVO or no (N)RVO?}
    \inputcpplisting{snippet24}
    \begin{itemize}
        \item \texttt{g1}: \only<1>{???}\only<2>{no RVO: \texttt{call S::S(S\&\&)}}
        \item \texttt{g2}: \only<1>{???}\only<2>{same as \texttt{g1}}
        \item \texttt{g3}: \only<1>{???}\only<2>{no RVO: \texttt{call S::S(const S\&)}}
        \item \texttt{g4}: \only<1>{???}\only<2>{same as \texttt{g3}}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{(N)RVO or no (N)RVO?}
    \begin{center}
        \scalebox{.7}{(derived from \href{https://youtu.be/ZxWjii99yao}{CppCon 2019: \textit{Jason Turner} \enquote{Great C++ is\_trivial}})}
    \end{center}

    \textbf{No (N)RVO in any of these examples!}
    \begin{lstlisting}
S g1() { auto [s1, s2] = f(); return s1; } // copy
S g2() { auto&& [s1, s2] = f(); return s1; } // copy: no implicit move yet (?)
S g3() { auto [s1, s2] = f(); return std::move(s1); } // move
S g4() { auto&& [s1, s2] = f(); return std::move(s1); } // move
    \end{lstlisting}
    
    \hfill \ldots \texttt{return std::move} is not always bad

    \textbf{Why?} Structured bindings:
    \begin{itemize}
        \item Creation of temporary object \texttt{e}
        \item Like a reference: structured binding is an alias into \texttt{e}
    \end{itemize}
\end{frame}

\begin{frame}{Implicit move}
    \begin{center}
        \scalebox{1.5}{\texttt{return std::move} is not yet necessarily a code smell}

        (use \texttt{-Wpessimizing-move})
    \end{center}

    \href{https://en.cppreference.com/w/cpp/language/return}{\textbf{Automatic move from local variables and parameters \underline{if}:}}
    \begin{itemize}
        \item return expression names a variable whose type is either
        \begin{itemize}
            \item an object type or (since \texttt{C++11})
            \item a rvalue reference to object type (since \texttt{C++20}${}^{\textcolor{vertexDarkRed}\star}$)
        \end{itemize}
        \item \ldots and that variable is declared
        \begin{itemize}
            \item in the body or
            \item as a parameter of
        \end{itemize}
        \item \ldots the innermost enclosing function or lambda expression
    \end{itemize}

    ${}^{\textcolor{vertexDarkRed}\star}$ \scalebox{.8}{\href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1825r0.html}{\texttt{P1825R0}} (not yet implemented in GCC or Clang: \href{https://en.cppreference.com/w/cpp/compiler_support}{cppreference.com/w/cpp/compiler\_support})}
\end{frame}

\begin{frame}[fragile]{Forwarding Values and Preserving Value Category}
    \centering

    \scalebox{.7}{(derived from \href{https://youtu.be/hwT8K3-NH1w}{CppCon 2018: \textit{Hayun Ezra Chung} \enquote{Forwarding Values... and Backwarding Them Too?})}}

    \only<1>{\inputcpplisting{snippet11a}}%
    \only<2>{\inputcpplisting{snippet11b}}%
    \only<3>{\inputcpplisting{snippet11c}}%
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \only<1>{\inputcpplisting{snippet18a}}%
    \only<2>{\inputcpplisting{snippet18b}}%
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \textbf{Q:} Why is this a bad idea?
    \begin{lstlisting}
auto&& visit(auto visitor) {
    auto&& result = visitor(resource);
    return result;
}
    \end{lstlisting}
    
    \only<2>{%
    \textbf{A:} Dangling reference for

    \centering
    \texttt{visit([](Resource \&r) -> Resource \{ return r; \}));}

    \vspace{.5cm}

    \begin{center}
        \scalebox{1.5}{\texttt{auto\&\&} is always a reference!}
    \end{center}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \only<1>{\inputcpplisting{snippet12a}}%
    \only<2>{\inputcpplisting{snippet12b}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \only<1>{\inputcpplisting{snippet13a}}%
    \only<2>{\inputcpplisting{snippet13b}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Category}
    \centering
    \only<1>{\inputcpplisting{snippet14a}}%
    \only<2,3>{%
        \only<3>{\textbf{\textcolor{vertexDarkRed}{error:}} cannot bind rvalue reference of type \enquote{Resource\&\&} to lvalue of type \enquote{Resource}}%
        \inputcpplisting{snippet14b}%
    }%
    \only<4>{\inputcpplisting{snippet14c}}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Categroy}
    \centering
    \scalebox{1.5}{How do we fuse these implementations?}

    \begin{lstlisting}
Resource visit(auto visitor) {
    Resource result = visitor(resource);
    return result;
}

Resource& visit(auto visitor) {
    Resource& result = visitor(resource);
    return result;
}

Resource&& visit(auto visitor) {
    Resource&& result = visitor(resource);
    return static_cast<Resource&&>(result);
}
    \end{lstlisting}

    \begin{lstlisting}
Target(rm.visit([](Resource &r) -> Resource { return r; }));
Target(rm.visit([](Resource &r) -> Resource& { return r; }));
Target(rm.visit([](Resource &r) -> Resource&& { return std::move(r); }));
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Backwarding Values and Preserving Value Categroy}
    \centering
    \scalebox{1.5}{How do we fuse these implementations?}

    \begin{lstlisting}
Resource visit(auto visitor) {
    Resource result = visitor(resource);
    return result;
}

Resource& visit(auto visitor) {
    Resource& result = visitor(resource);
    return result;
}

Resource&& visit(auto visitor) {
    Resource&& result = visitor(resource);
    return static_cast<Resource&&>(result);
}
    \end{lstlisting}

    \begin{lstlisting}
decltype(auto) visit(auto visitor) {
    decltype(auto) result = visitor(resource);
    return static_cast<decltype(result)>(result);
}
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile,plain,noframenumbering]
    \centering
    \scalebox{.7}{(derived from \href{https://youtu.be/hwT8K3-NH1w}{CppCon 2018: \textit{Hayun Ezra Chung} \enquote{Forwarding Values... and Backwarding Them Too?})}}

    \inputcpplisting{snippet15}
\end{frame}

\begin{frame}[plain,noframenumbering]
    \centering
    \scalebox{5.}{\color{vertexDarkRed}$*$}
\end{frame}

\begin{frame}[fragile]{Q: What is the output of the program?}
    \inputcpplisting{snippet16a}
\end{frame}

\begin{frame}[fragile]{A: \texttt{a}}
    \inputcpplisting{snippet16a}
\end{frame}

\begin{frame}[fragile]{Q: What is the output of the program?}
    \inputcpplisting{snippet16b}
\end{frame}

\begin{frame}[fragile]{A: \texttt{aa}}
    \inputcpplisting{snippet16b}
\end{frame}

\begin{frame}[fragile]{Missing (N)RVO}
    \begin{lstlisting}
struct Resource {
    [...]
    Resource(const Resource&) { std::cout << 'a'; }
};

Resource visit(auto visitor) {
    Resource result = visitor(resource);
    return static_cast<Resource>(result);
}
    \end{lstlisting}

    \textbf{Neither RVO nor NRVO!}
    \begin{itemize}
        \item \texttt{static\_cast} is not the name of a variable (c-style cast does not work either)
        \item compiler cannot elide observable side effects of copy construction
        \item \enquote{Solution}
        \begin{itemize}
            \item remove explicit cast, or
            \item remove side effect (\texttt{std::cout})
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Missing (N)RVO}
    \begin{lstlisting}
template <typename T>
decltype(auto) visit(T visitor) {
    decltype(auto) result = visitor(resource);
    if constexpr (std::is_same_v<decltype(result), Resource&&>) {
        return std::move(result);
    } else {
        return result;
    }
}
    \end{lstlisting}

    \hfill \ldots works for GCC (without \texttt{auto} concept), not for Clang though
\end{frame}

\begin{frame}[fragile]{Missing (N)RVO}
    \begin{lstlisting}
template <typename T>
static constexpr bool returns_rref = std::is_same_v<std::invoke_result_t<T, Resource&>, Resource&&>;

template <typename T, std::enable_if_t<returns_rref<T>, int> = 0>
decltype(auto) visit(T visitor) {
    decltype(auto) result = visitor(resource);
    return std::move(result);
}

template <typename T, std::enable_if_t<not returns_rref<T>, int> = 0>
decltype(auto) visit(T visitor) {
    decltype(auto) result = visitor(resource);
    return result;
}
    \end{lstlisting}

    \hfill \ldots still, no NRVO with Clang but this time due to the deduced return type!
\end{frame}

\begin{frame}[fragile]{Missing (N)RVO}
    \begin{lstlisting}
template <typename T>
static constexpr bool returns_rref = std::is_same_v<std::invoke_result_t<T, Resource&>, Resource&&>;

template <typename T, std::enable_if_t<returns_rref<T>, int> = 0>
decltype(auto) visit(T visitor) {
    decltype(auto) result = visitor(resource);
    return std::move(result);
}

template <typename T, std::enable_if_t<not returns_rref<T>, int> = 0>
auto visit(T visitor) -> decltype(visitor(resource)) {
    decltype(auto) result = visitor(resource);
    return result;
}
    \end{lstlisting}

    \hfill \ldots now works for GCC and Clang!
\end{frame}

\begin{frame}[fragile,plain,noframenumbering]
    \inputcpplisting{snippet17}
\end{frame}

\begin{frame}[fragile,plain,noframenumbering]
    \scalebox{3.}{More things that don't work}
\end{frame}

\begin{frame}[fragile]{Missing (N)RVO}
    \inputcpplisting{snippet19a}

    \hfill \ldots works with GCC, fails with Clang
\end{frame}


\begin{frame}[fragile]{Missing (N)RVO}
    \inputcpplisting{snippet19b}

    \hfill \ldots works with Clang, fails with GCC
\end{frame}

\begin{frame}[fragile]{Missing (N)RVO}
    \inputcpplisting{snippet19c}

    \hfill \ldots fails with GCC and Clang
\end{frame}

\begin{frame}{Conclusion}
    \begin{center}
        \scalebox{.7}{(shamelessly copied from \href{https://youtu.be/hwT8K3-NH1w}{CppCon 2018: \textit{Hayun Ezra Chung} \enquote{Forwarding Values... and Backwarding Them Too?})}}
    \end{center}
    
    \textbf{Forwarding}
    \begin{itemize}
        \item Parameter Type: \texttt{T\&\&}
        \item Function Argument: \texttt{std::forward<E>(e)}
        \item Alternatively: \texttt{static\_cast<decltype(e)\&\&>(e)}
    \end{itemize}

    \textbf{Backwarding}
    \begin{itemize}
        \item Parameter Type: \texttt{decltype(auto)}
        \item Function Argument: \texttt{decltype(e)(e)}
        \item Alternatively: \texttt{static\_cast<decltype(e)>(e)}$^*$
    \end{itemize}
\end{frame}

\end{document}
